%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% pseudocode.sty, by Dario Sneidermanis
%
% Based on package `clrscode3e', written by Thomas H. Cormen:
%
% Package for producing pseudocode in the style of Cormen, Leiserson,
% Rivest, and Stein, Introduction to Algorithms, Third edition.
%
% http://www.cs.dartmouth.edu/~thc/clrscode/
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\ProvidesPackage{pseudocode}


\RequirePackage{graphics} % needed for \scalebox command
\RequirePackage{xparse}   % needed for \Function command


%%%%%%%%%%%%%%%%%%%%%%%
% Formatting commands %
%%%%%%%%%%%%%%%%%%%%%%%


% Tiny space
\newcommand{\tsp}{\hspace*{0.5pt}}

% Command for typesetting constants
\newcommand{\const}[1]{\textnormal{\scshape#1}} %  \const{true}, \const{nil}

% Command for typesetting procedure names
\newcommand{\proc}[1]{\textnormal{\scshape#1}} %  \proc{Insertion-Sort}


\newcommand{\text@hyphens}{\mathcode`\-=`\-\relax}

% Command for typesetting fixed functions
\newcommand{\func}[1]{%
    \ensuremath{{\mathop{\text@hyphens\operator@font#1}\nolimits}}} %  \func{sin}, \func{out-degree}

% Command for typesetting identifiers
\newcommand{\id}[1]{%
    \ensuremath{\mathit{\text@hyphens#1}}} %  \id{key}, \id{left-sum}

% Command for typesetting subarray ranges.
\newcommand{\twodots}{\mathinner{\ldotp\ldotp}} %  $[1 \twodots n]$

% Command for typesetting object attributes.
\newcommand{\member}[2]{\id{#1}\ensuremath{\tsp . \tsp}\id{#2}} %  \member{user}{name}

% Command for typesetting array elements.
\newcommand{\at}[2]{\id{#1}\tsp[\id{#2}]} %  \at{names}{pos}


%%%%%%%%%%%%%%%%%%%%%%%
% codebox environment %
%%%%%%%%%%%%%%%%%%%%%%%


% When we make a codebox, we save the code part into a box before
% printing it.  We do not actually print the code until we know how many
% line numbers there are.
\newsavebox{\savecode}

% The \ifprocname command tells us whether this procedure has been
% given a name yet.
\newif\ifprocname

% The \iffirstcodeline command tells us whether we are about to
% produce the first line other than the procedure declaration.
\newif\iffirstcodeline

% \digitwidth gives the width of a single digit.  All digits are the
% same width.  We'll need this amount to do the right thing for line
% numbers.
\newlength{\digitwidth}
\settowidth{\digitwidth}{0}

% Assume that the width of the codebox is the width of the text, minus
% the width of 2 digits.  We'll correct for that later.
\newlength{\codeboxwidth}
\setlength{\codeboxwidth}{\linewidth} % Thanks, David Etherington!
\addtolength{\codeboxwidth}{-2\digitwidth}

% The codelinenumber counter counts the current line number.
\newcounter{codelinenumber}

% The indent counter keeps track of the current indentation level.
\newcounter{indent}

% THC: This next command is magic to me.  I didn't write it.
\def\@startline{\global\@curtabmar\@nxttabmar\relax
   \global\@curtab\@curtabmar\setbox\@curline\hbox
    {}\@startfield\strut}

% The "codebox" environment produces an unbreakable section of code
\newenvironment{codebox}{%
    % this proc hasn't been given a name yet
    \global\procnamefalse%
    % producing the first line
    \setcounter{codelinenumber}{0}%
    \setcounter{indent}{0}%
    \firstcodelinetrue%
    % distance between numbers and code
    \setlength{\tabbingsep}{1em}%
    % Initialize \@lilabel to allow a pageref \label cmd at the beginning of the codebox
    \global\let\@lilabel\@currentlabel
    \def\@currentlabel{\@lilabel}%
    % save the code into a box
    \begin{lrbox}{\savecode}%
    % it'll be a minipage
    \begin{minipage}[t]{\codeboxwidth}%
    % set up the tab stops
    \def\codeindent{\textbf{else} }%
    \begin{tabbing}%
    99\=\codeindent\=\codeindent\=\codeindent\=\codeindent\=\codeindent\=\codeindent\=\codeindent\=codeindent\=codeindent\=\+\kill%
}{%
    % Here's what's run at the end of a codebox environment.  Start by
    % making sure that we have ended at indent level 0.  Otherwise, print a
    % warning.
    \ifnum\value{indent}=0\else\typeout{Warning: Indentation ends at level \theindent\space in codebox on page \thepage.}\fi%
    % close all open environments
    \end{tabbing}%
    \end{minipage}%
    \end{lrbox}%
    % for the following trivlist
    \addtolength{\topsep}{0.5ex}%
    \begin{trivlist}\item\parindent=0pt%
        % If there was a procedure name given, print it now but with a little
        % space below, and disallow a page break after the procedure name.
        \@nobreaktrue%
        \ifprocname\saveprocname\rule[-2ex]{0pt}{0pt}\\ \fi%
        % Put in the right amount of space, depending on whether we reached
        % double digits in the line numbers.
        \ifnum\value{codelinenumber}>9\hspace*{2\digitwidth}\else\hspace*{1\digitwidth}\fi%
        % Now print the code
        \usebox{\savecode}%
    \end{trivlist}%
    \addtolength{\topsep}{-0.5ex}%
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% codebox environment commands %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newcounter{thisindent}         % counter for recursive indenting code
\newcommand{\Indent}{\setcounter{thisindent}{\value{indent}}\putindents}
% \putindents is a recursive macro that indents a number of times given
% by the counter thisindent.
\newcommand{\putindents}{\ifnum\value{thisindent}>0\>\addtocounter{thisindent}{-1}\putindents\fi}

% For typesetting any keyword in the main text.
\newcommand{\kw}[1]{\textbf{#1}}

% Override the 'gets' symbol.
%\def\gets{\mathrel{\hspace{1pt}=\hspace{1pt}}}
%\newcommand{\isequal}{\mathrel{\scalebox{0.8}[1]{=}\hspace*{1pt}\scalebox{0.8}[1]{=}}}
\newcommand{\isequal}{=}

% All of our favorite keywords.
\newcommand{\For}{\textbf{for} }
\newcommand{\To}{\ifmmode\ \textrm{\textbf{to}}\ \else\textbf{to}\ \fi}
\newcommand{\By}{\ifmmode\ \textrm{\textbf{by}}\ \else\textbf{by}\ \fi}
\newcommand{\Downto}{\ifmmode\ \textrm{\textbf{downto}}\ \else\textbf{downto}\ \fi}
\newcommand{\While}{\textbf{while} }
\newcommand{\Repeat}{\textbf{repeat}\>\addtocounter{indent}{1}}
\newcommand{\Until}{\kill\addtocounter{indent}{-1}\liprint\textbf{until} }
\newcommand{\If}{\textbf{if} }
\newcommand{\Then}{\>\addtocounter{indent}{1}}
\newcommand{\Else}{\kill\addtocounter{indent}{-1}\liprint\textbf{else}\>\addtocounter{indent}{1}}
\newcommand{\End}{\addtocounter{indent}{-1}}
\newcommand{\ElseIf}{\kill\addtocounter{indent}{-1}\liprint\textbf{elseif} }
\newcommand{\ElseNoIf}{\kill\addtocounter{indent}{-1}\liprint\textbf{else} \addtocounter{indent}{1}}
\newcommand{\Do}{\>\addtocounter{indent}{1}}
\newcommand{\Return}{\textbf{return} }
\newcommand{\CommentSymbol}{\texttt{\textbf{/\hspace*{-0.3em}/}}}
\newcommand{\Comment}{\CommentSymbol\ }
\newcommand{\RComment}{\`\CommentSymbol\ }
\newcommand{\Goto}{\textbf{goto} }
\newcommand{\Error}{\textbf{error} } % optionally followed by string argument
\newcommand{\EndTest}{\textbf{:}}
\newcommand{\Spawn}{\ifmmode\textbf{spawn}\ \else\textbf{spawn} \fi}
\newcommand{\Sync}{\textbf{sync}}
\newcommand{\Parfor}{\textbf{parallel for} }

% Indent the next line one level more
\newcommand{\Indentmore}{\addtocounter{indent}{1}}

\newif\ifnumberedline
\numberedlinetrue

% The \li command starts a new numbered line.
\newcommand{\li}{\global\numberedlinetrue%
\iffirstcodeline\global\firstcodelinefalse\else\\[2pt] \fi
\stepcounter{codelinenumber}%
\liprint}

% The \lispace command starts a new numbered line with a little extra
% space above, given by the argument.
\newcommand{\lispace}[1]{\iffirstcodeline\global\firstcodelinefalse\else\\[#1] \fi
\stepcounter{codelinenumber}%
\liprint}

\newcommand{\liempty}{\lispace{0pt}\lispace{0pt}}

% \liprint actually prints the line number and sets up the indentation.
\newcommand{\liprint}{\protected@xdef\@lilabel{\thecodelinenumber}%
\ifnumberedline\thecodelinenumber\fi\'\Indent%
}

\providecommand{\numref}[1]{%
  \@ifundefined{r@#1}{000}{%
    \expandafter\expandafter\expandafter\@firstoftwo
    \csname r@#1\endcsname
  }%
}

% \setlinenumber sets the line number to its argument
\newcommand{\setlinenumber}[1]{\setcounter{codelinenumber}{\numref{#1}}%
\addtocounter{codelinenumber}{-1}}
% \setlinenumberplus sets the line number to its first argument plus its
% second argument.
\newcommand{\setlinenumberplus}[2]{\setcounter{codelinenumber}{\numref{#1}}%
\addtocounter{codelinenumber}{-1}\addtocounter{codelinenumber}{#2}}

% The \zi command starts a new unnumbered line.
\newcommand{\zi}{\global\numberedlinefalse%
\iffirstcodeline\global\firstcodelinefalse\else\\ \fi
\liprint}

% Temporarily make all lines indented so that they start at the end of
% a given text.
\newcommand{\Startalign}[1]{\\ \pushtabs\FakeIndent#1\=\kill}
\newcommand{\Stopalign}{\poptabs}
\newcommand{\FakeIndent}{\setcounter{thisindent}{\value{indent}}\putfakeindents}
\newcommand{\putfakeindents}{\ifnum\value{thisindent}>0\textbf{else }\addtocounter{thisindent}{-1}\putfakeindents\fi}


\ExplSyntaxOn

\NewDocumentCommand{\Function}{ m g } {
    \global\def\saveprocname{
        \proc{#1}
        \IfNoValueF{#2} { \tsp ( \ArgList{#2} ) }
    }
    \global\procnametrue
}

\newif\iffirstarg

\NewDocumentCommand{\ArgList}{ >{\SplitList{,}} m } {
    \global\firstargtrue
    \ProcessList{#1}{\Arg}
}

\NewDocumentCommand{\Arg}{ >{\SplitArgument{1}{=}} m } {
    \AArg #1
}

\NewDocumentCommand{\AArg}{ m m } {
    \iffirstarg\global\firstargfalse\else{,\ }\fi
    \hspace*{-1pt} \id{#1}
    \IfNoValueF{#2} {\tsp : \; #2}
}

\ExplSyntaxOff


\endinput

